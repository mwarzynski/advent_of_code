# This was mostly generated by ChatGPT.
#
# I wanted to see how easy it's going to be, but looks like the o1 model is not as powerful.
# It took me dozens of tries to get to an almost correct solution,
# but at the end I had to fix it myself.
# Maybe I don't know how to prompt it...

from typing import List, Tuple, Optional
from dataclasses import dataclass


@dataclass
class DiskBlock:

    index: int
    length: int
    # file_id defines the File for which the Content is stored
    # if DiskBlock represents empty space, then this ID is None
    file_id: Optional[int]

    def index_range(self) -> Tuple[int, int]:
        """index_range returns [a,b) range for the block"""
        return (self.index, self.index + self.length)


class DiskTreeNode:
    def __init__(self, block: Optional[DiskBlock] = None) -> None:
        self.children = []
        self.values = []
        if block:
            self.values.append(block)

    def insert(self, block: DiskBlock):
        """Insert a block into the tree node."""
        # If the node has no children, store the block directly
        if not self.children:
            self.values.append(block)
            return

        # Try inserting into a child node
        for child in self.children:
            if child.can_fit(block):
                child.insert(block)
                return

        # If no child can fit, create a new child node
        new_node = DiskTreeNode(block)
        self.children.append(new_node)

    def can_fit(self, block: DiskBlock) -> bool:
        """Check if a block can fit in the node's range."""
        for value in self.values:
            if value.index <= block.index < value.index + value.length:
                return True
        return False


class DiskTree:

    def __init__(self, blocks: List[DiskBlock]) -> None:
        self.root = DiskTreeNode()
        for block in blocks:
            self.root.insert(block)

    def block_leftfill(self, file_id: int, length: int, max_i: int) -> int:
        """
        Returns how many units of length were successfully left-filled up to max_i.
        If partial fill occurs, returns the number of units filled.
        If none is filled, returns 0.
        """
        return self._leftfill_recursive(self.root, file_id, length, max_i)

    def _leftfill_recursive(self, node: DiskTreeNode, file_id: int, remaining_length: int, max_i: int) -> int:
        if remaining_length == 0:
            return 0

        filled = 0
        # Try to fill current node's blocks
        for block in sorted(node.values, key=lambda b: b.index):
            if block.file_id is None:
                block_start, block_end = block.index_range()
                if block_start >= max_i:
                    continue
                usable_length = min(block.length, remaining_length, max_i - block_start)
                if usable_length > 0:
                    block.file_id = file_id
                    filled += usable_length
                    remaining_length -= usable_length
                    if usable_length < block.length:
                        # Split the block
                        new_block = DiskBlock(
                            index=block.index + usable_length, length=block.length - usable_length, file_id=None
                        )
                        block.length = usable_length
                        node.values.append(new_block)
                    if remaining_length == 0:
                        break

        # If still remaining, try children
        if remaining_length > 0:
            for child in node.children:
                child_filled = self._leftfill_recursive(child, file_id, remaining_length, max_i)
                filled += child_filled
                remaining_length -= child_filled
                if remaining_length == 0:
                    break

        return filled

    def block_reset(self, index_range: Tuple[int, int]):
        """Reset blocks within the given index range."""
        start, end = index_range
        self._reset_recursive(self.root, start, end)

    def _reset_recursive(self, node: DiskTreeNode, start: int, end: int):
        updated_values = []
        for block in node.values:
            block_start, block_end = block.index_range()

            # If block is completely outside the reset range, keep it as is
            if block_end <= start or block_start >= end:
                updated_values.append(block)
                continue

            # If block is completely within the reset range
            if start <= block_start and block_end <= end:
                # Entire block is reset to free space
                block.file_id = None
                updated_values.append(block)
                continue

            # Partial overlaps:
            # 1. Overlap on the left side
            if block_start < start < block_end:
                # If end < block_end, then start is inside block, and we might have a triple split scenario
                if end < block_end:
                    # Triple split:
                    # Left portion: [block_start, start) keeps original file_id
                    left_block = DiskBlock(index=block_start, length=start - block_start, file_id=block.file_id)
                    # Middle portion: [start, end) reset to free
                    mid_block = DiskBlock(index=start, length=end - start, file_id=None)
                    # Right portion: [end, block_end) keeps original file_id
                    right_block = DiskBlock(index=end, length=block_end - end, file_id=block.file_id)

                    updated_values.append(left_block)
                    updated_values.append(mid_block)
                    updated_values.append(right_block)
                else:
                    # Overlap only at start side:
                    # Left portion: [block_start, start) keeps file_id
                    left_block = DiskBlock(index=block_start, length=start - block_start, file_id=block.file_id)
                    # Right portion: [start, block_end) inside reset range => reset to free
                    right_block = DiskBlock(index=start, length=block_end - start, file_id=None)

                    updated_values.append(left_block)
                    updated_values.append(right_block)
                continue

            # 2. Overlap on the right side (we know block_start < end < block_end here)
            if block_start < end < block_end:
                # If start > block_start, we already handled that scenario above.
                # This means start <= block_start < end < block_end
                # Left portion: [block_start, end) reset to free
                left_block = DiskBlock(index=block_start, length=end - block_start, file_id=None)
                # Right portion: [end, block_end) keeps file_id
                right_block = DiskBlock(index=end, length=block_end - end, file_id=block.file_id)

                updated_values.append(left_block)
                updated_values.append(right_block)
                continue

        node.values = updated_values

        for child in node.children:
            self._reset_recursive(child, start, end)

    def blocks(self) -> List[DiskBlock]:
        """Retrieve all blocks as a flat list."""
        flat_blocks = []
        self._collect_blocks(self.root, flat_blocks)
        return sorted(flat_blocks, key=lambda b: b.index)

    def _collect_blocks(self, node: DiskTreeNode, flat_blocks: List[DiskBlock]):
        """Helper to collect all blocks in a flat list."""
        flat_blocks.extend(node.values)
        for child in node.children:
            self._collect_blocks(child, flat_blocks)


class Disk:

    _blocks: List[DiskBlock]

    def __init__(self, memory_dense: Optional[str] = None, blocks: Optional[List[DiskBlock]] = None) -> None:
        if memory_dense:
            self._blocks = self._parse_blocks_from_memory_dense(memory_dense)
        elif blocks:
            self._blocks = blocks

    def _parse_blocks_from_memory_dense(self, memory_dense: str) -> List[DiskBlock]:
        blocks = []
        block_current_index = 0
        for i, block_length in enumerate(memory_dense):
            block_length = int(block_length)
            if block_length == 0:
                continue
            disk_block: DiskBlock
            if i % 2 == 0:
                file_id = int(i / 2)
                disk_block = DiskBlock(index=block_current_index, file_id=file_id, length=block_length)
            else:
                disk_block = DiskBlock(index=block_current_index, file_id=None, length=block_length)
            block_current_index += block_length
            blocks.append(disk_block)
        return blocks

    def blocks(self) -> List[DiskBlock]:
        return self._blocks

    def fragment(self):
        tree = DiskTree(self._blocks)
        for block in reversed(self._blocks):
            if block.file_id is None:
                continue
            block_range = block.index_range()
            fill_count = tree.block_leftfill(block.file_id, block.length, block_range[0])
            if fill_count == block.length:
                # Fully moved, reset entire block range
                tree.block_reset(block.index_range())
            elif fill_count > 0:
                # Partially moved, reset only the portion that got filled
                to_remove = block.length - fill_count + 1
                # print(f"fragment - block_reset fill_count: {to_remove}, {block.index + fill_count} -> {block_range[1]}")
                tree.block_reset((block_range[1] - to_remove - 1, block_range[1]))
            else:
                # Couldn't move anything
                break
        self._blocks = tree.blocks()

    def checksum(self) -> str:
        """
        Calculate the checksum of the disk. Multiply each block's position by its file ID
        and sum these values, ignoring blocks with no file ID (free space).
        """
        checksum = 0
        position = 0

        for block in self._blocks:
            if block.file_id is not None:
                for i in range(block.length):
                    checksum += (position + i) * block.file_id
                    # print(f"+= {position+i} * {block.file_id}")
            position += block.length

        return str(checksum)


def main():
    with open("./input.prod") as f:
        disk = Disk(memory_dense=f.read().strip())
    disk.fragment()
    print(disk.checksum())


if __name__ == "__main__":
    main()
